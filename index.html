<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ç«¶è‰‡ã‚ªãƒƒã‚ºäºˆæƒ³ã‚²ãƒ¼ãƒ ï¼ˆå®Œå…¨ç‰ˆï¼š3ç”»é¢ï¼‰</title>
  <style>
    :root{--bg:#f6f7fb;--card:#fff;--line:#e6e7ee;--muted:#666;--txt:#111;--blue:#2f6feb;--blue2:#1f5edb;--soft:#f2f6ff;}
    body { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Sans", "Noto Sans JP", sans-serif; margin: 0; background: var(--bg); color: var(--txt); }
    header { padding: 16px; background: #ffffff; position: sticky; top: 0; border-bottom: 1px solid var(--line); z-index: 10; }
    h1 { margin: 0; font-size: 18px; }
    .wrap { padding: 14px; max-width: 980px; margin: 0 auto; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; }
    .card { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.03); }
    .card h2 { margin: 0 0 10px; font-size: 15px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 8px; border-bottom: 1px solid #f0f1f6; text-align: left; vertical-align: top; }
    th { color: #555; font-weight: 600; }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: #f0f2ff; border: 1px solid #dfe4ff; font-size: 13px; }
    .kpi { display: flex; gap: 10px; flex-wrap: wrap; }
    .kpi .pill { background: #f5fbff; border-color: #d8f1ff; }
    .controls { display: grid; gap: 10px; }
    label { font-size: 13px; color: #444; display: grid; gap: 6px; }
    select, input { font-size: 16px; padding: 10px 12px; border-radius: 12px; border: 1px solid #dcdde6; background: #fff; }
    button { font-size: 16px; padding: 12px 14px; border-radius: 12px; border: 1px solid #dcdde6; background: #111; color: #fff; cursor: pointer; }
    button.secondary { background: #fff; color: #111; }
    button:disabled{ opacity:0.55; cursor:not-allowed; }
    .btns { display: flex; gap: 10px; flex-wrap: wrap; }
    .muted { color: var(--muted); font-size: 13px; }
    .result { font-size: 15px; line-height: 1.6; }
    .hit { color: #0a7a2f; font-weight: 800; }
    .miss { color: #b00020; font-weight: 800; }
    .small { font-size: 12px; color: var(--muted); }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .mono { font-variant-numeric: tabular-nums; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--line); font-size:12px; }
    .b-good { background:#f1fff4; border-color:#c8f2d1; }
    .b-mid  { background:#fffdf1; border-color:#f3e8b3; }
    .b-bad  { background:#fff1f1; border-color:#f2c8c8; }

    /* ===== 3ç”»é¢ ===== */
    .screen{ display:none; }
    .screen.active{ display:block; }

    /* ===== Formation UI ===== */
    .formationShell{border:1px solid var(--line);border-radius:14px;overflow:hidden;background:#fff;}
    .formationTop{display:flex;gap:10px;padding:10px;background:linear-gradient(180deg,var(--soft),#fff);border-bottom:1px solid var(--line);align-items:center;flex-wrap:wrap;}
    .formationTable{width:100%;border-collapse:separate;border-spacing:0;}
    .formationTable td{padding:8px;border-bottom:1px solid #f0f1f6;vertical-align:middle;}
    .colLane{width:54px;text-align:center;font-weight:800;color:#111;border-right:1px solid #f0f1f6;}
    .laneBar{width:10px;height:42px;border-radius:6px;margin:0 auto;border:1px solid rgba(0,0,0,0.08);}
    .lane1{background:#fff;}
    .lane2{background:#000;}
    .lane3{background:#e60012;}
    .lane4{background:#0057ff;}
    .lane5{background:#ffcc00;}
    .lane6{background:#1ea64a;}
    .laneNum{font-size:12px;margin-top:6px;color:#333;}
    .playerBox{line-height:1.2;}
    .playerBox b{font-size:13px;}
    .playerMeta{font-size:11px;color:#666;margin-top:2px;}
    .pickGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;min-width:210px;}
    .pickGrid.cols2{grid-template-columns:repeat(2,1fr);min-width:150px;}
    .pickGrid.cols1{grid-template-columns:repeat(1,1fr);min-width:70px;}
    .pickBtn{appearance:none;border:2px solid #d7e3ff;background:#fff;border-radius:10px;padding:10px 0;font-weight:900;color:#1f5edb;cursor:pointer;user-select:none;text-align:center;box-shadow:0 1px 0 rgba(0,0,0,0.03);}
    .pickBtn.on{background:var(--blue);border-color:var(--blue2);color:#fff;}
    .pickHeadRow{display:grid;grid-template-columns:54px 1fr 240px;gap:0;}
    .pickHeadRow>div{padding:8px;font-size:12px;color:#555;background:#f4f7ff;border-bottom:1px solid var(--line);}
    .pickHeadRow .ph2{border-left:1px solid #f0f1f6;border-right:1px solid #f0f1f6;}
    .pickHeadRow .ph3{text-align:center;}
    .pickHeadLabels{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;font-weight:800;color:#355;}
    .pickHeadLabels.cols2{grid-template-columns:repeat(2,1fr);}
    .pickHeadLabels.cols1{grid-template-columns:repeat(1,1fr);}
    .formationBottom{display:flex;gap:10px;align-items:center;padding:10px;border-top:1px solid var(--line);background:#fff;flex-wrap:wrap;}
    .miniBtn{border:1px solid #dcdde6;background:#fff;color:#111;padding:10px 12px;border-radius:12px;cursor:pointer;font-size:14px;}
    .sumBox{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-left:auto;}

    /* ===== Race canvas big ===== */
    .raceStage{
      width:100%;
      height:52vh;            /* â˜…åŠåˆ†ãã‚‰ã„å¤§ãã */
      min-height:360px;
      border:1px solid var(--line);
      border-radius:12px;
      background:#fff;
      overflow:hidden;
    }
    #raceCanvas{
      width:100%;
      height:100%;
      display:block;
    }
  </style>
</head>

<body>
<header>
  <h1>ğŸš¤ ç«¶è‰‡ã‚ªãƒƒã‚ºäºˆæƒ³ã‚²ãƒ¼ãƒ ï¼ˆå±•ç¤ºâ†’è²·ã„ç›®â†’è³¼å…¥â†’ãƒ¬ãƒ¼ã‚¹â†’çµæœï¼‰</h1>
  <div class="kpi" style="margin-top:10px">
    <span class="pill">æ‰€æŒé‡‘: <b id="money">10000</b>å††</span>
    <span class="pill">å›åç‡: <b id="roi">0.0</b>%</span>
    <span class="pill">çš„ä¸­ç‡: <b id="hitRate">0.0</b>%</span>
  </div>
</header>

<div class="wrap">

  <!-- ===== ç”»é¢1ï¼šå±•ç¤ºï¼‹è²·ã„ç›®ï¼‹è³¼å…¥ ===== -->
  <section id="screenBet" class="screen active">
    <div class="row">
      <div class="card" style="flex:1 1 640px;">
        <h2>å±•ç¤ºæƒ…å ±</h2>

        <div class="grid2" style="margin-bottom:10px;">
          <label>å ´
            <select id="venue"></select>
          </label>
          <div class="row" style="align-items:flex-end;">
            <span class="pill">é¢¨: <b id="wind">-</b>m</span>
            <span class="pill">æ³¢: <b id="wave">-</b>cm</span>
          </div>
        </div>

        <div class="row" style="margin-bottom:10px;">
          <span class="pill">æ°´é¢å‚¾å‘: <b id="trend">-</b></span>
          <span class="pill">è’ã‚Œ: <b id="chaosLabel">-</b></span>
          <span class="pill">ã‚³ãƒ¼ã‚¹å‚¾å‘: <b id="laneTrend">-</b></span>
        </div>

        <table>
          <thead>
            <tr>
              <th>è‰‡</th><th>å±•ç¤ºé †ä½</th><th>ç›´å‰æ°—é…</th><th>ãƒ©ãƒ³ã‚¯</th><th>å±•ç¤º</th><th>å±•ç¤ºST</th><th>ãƒ¢ãƒ¼ã‚¿ãƒ¼</th><th>å¼·ã•</th><th>æœ¬ç•ªST</th>
            </tr>
          </thead>
          <tbody id="boats"></tbody>
        </table>

        <div class="btns" style="margin-top:12px;">
          <button class="secondary" id="newRace">ãƒ¬ãƒ¼ã‚¹æ›´æ–°</button>
        </div>

        <p class="muted" style="margin-top:10px;">
          â€» å®Ÿãƒ‡ãƒ¼ã‚¿ã§ã¯ãªãã€å±•ç¤º/å±•ç¤ºST/é¢¨æ³¢/å ´ç‰¹å¾´ï¼‹ã€Œãƒ¢ãƒ¼ã‚¿ãƒ¼2é€£å¯¾ç‡ãƒ»3é€£å¯¾ç‡ã€ã€Œé¸æ‰‹ãƒ©ãƒ³ã‚¯ã€ã€Œã‚³ãƒ¼ã‚¹è£œæ­£ã€ã§å¼·ã•ãƒ»ã‚ªãƒƒã‚ºãƒ»çµæœã‚’ç”Ÿæˆã€‚
        </p>
      </div>

      <div class="card" style="flex:1 1 280px;">
        <h2>è²·ã„ç›®ï¼ˆã“ã“ã§é‡‘é¡ãªã©æ±ºã‚ã‚‹ï¼‰</h2>

        <div class="controls">
          <label>å¼åˆ¥ï¼ˆå…¨éƒ¨ãƒ•ã‚©ãƒ¼ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
            <select id="betType">
              <option value="win">å˜å‹ï¼ˆ1ç€ï¼‰</option>
              <option value="exacta">2é€£å˜</option>
              <option value="trifecta" selected>3é€£å˜</option>
            </select>
          </label>

          <label>è³¼å…¥ï¼ˆ1ç‚¹ã‚ãŸã‚Šï¼‰
            <input id="stake" inputmode="numeric" pattern="[0-9]*" value="100" />
            <span class="small">â€» 100å††ä»¥ä¸Š</span>
          </label>

          <div class="pill">æƒ³å®šã‚ªãƒƒã‚º: <b id="previewOdds">-</b></div>
          <div class="pill">ç‚¹æ•°: <b id="combos">0</b>ç‚¹ / ç·æŠ•è³‡: <b id="totalStake">0</b>å††</div>

          <div class="btns">
            <button id="buyRun">è³¼å…¥ã—ã¦ãƒ¬ãƒ¼ã‚¹é–‹å§‹</button>
          </div>

          <div class="muted">ãƒ«ãƒ¼ãƒ«: æœ¬ç•ªSTãŒ <b>0.03æœªæº€ã§F</b>ã€<b>0.28è¶…ã§L</b>ï¼ˆã“ã®ã‚²ãƒ¼ãƒ ã§ã¯é™¤å¤–æ‰±ã„ï¼‰</div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <h2>è²·ã„ç›®ï¼ˆæŠ¼ã™ã ã‘ï¼‰</h2>

      <div class="formationShell">
        <div class="formationTop">
          <div class="muted" id="formationHint">3é€£å˜ï¼š3åˆ—ãœã‚“ã¶æŠ¼ã—ã¦è²·ã†ï¼ˆåŒä¸€è‰‡ã¯è‡ªå‹•ã§é™¤å¤–ï¼‰</div>
        </div>

        <div class="pickHeadRow">
          <div>æ </div>
          <div class="ph2">ç´šåˆ¥ãƒ»å±•ç¤ºï¼ˆä»®ï¼‰</div>
          <div class="ph3">
            <div id="headLabels" class="pickHeadLabels">
              <div style="text-align:center;">1ç€</div>
              <div style="text-align:center;">2ç€</div>
              <div style="text-align:center;">3ç€</div>
            </div>
          </div>
        </div>

        <table class="formationTable"><tbody id="formationBody"></tbody></table>

        <div class="formationBottom">
          <button class="miniBtn" id="all1">1ç€ å…¨</button>
          <button class="miniBtn" id="all2">2ç€ å…¨</button>
          <button class="miniBtn" id="all3">3ç€ å…¨</button>
          <button class="miniBtn" id="clearAll">å…¨éƒ¨ã‚¯ãƒªã‚¢</button>
          <div class="sumBox">
            <span class="pill">ç‚¹æ•°: <b id="combos2">0</b>ç‚¹</span>
            <span class="pill">ç·æŠ•è³‡: <b id="totalStake2">0</b>å††</span>
          </div>
        </div>
      </div>

      <div class="small muted" style="margin-top:8px;">â€» åŒã˜è‰‡ãŒè¤‡æ•°ç€ã«è¢«ã‚‹çµ„ã¿åˆã‚ã›ã¯è‡ªå‹•ã§é™¤å¤–ã€‚</div>
    </div>
  </section>

  <!-- ===== ç”»é¢2ï¼šãƒ¬ãƒ¼ã‚¹æ˜ åƒ ===== -->
  <section id="screenRace" class="screen">
    <div class="card">
      <h2>ãƒ¬ãƒ¼ã‚¹æ˜ åƒï¼ˆå·¦â†’å³ã‚¹ã‚¿ãƒ¼ãƒˆ / åæ™‚è¨ˆå›ã‚Š / 3å‘¨ / ä¸‹ãŒã‚¹ã‚¿ãƒ¼ãƒˆ=ã‚´ãƒ¼ãƒ«ï¼‰</h2>
      <div class="raceStage">
        <canvas id="raceCanvas"></canvas>
      </div>
      <div class="muted" style="margin-top:8px;">â€» çµæœã¯ã‚´ãƒ¼ãƒ«å¾Œã«è¡¨ç¤º</div>
    </div>
  </section>

  <!-- ===== ç”»é¢3ï¼šçµæœ ===== -->
  <section id="screenResult" class="screen">
    <div class="card">
      <h2>çµæœ</h2>
      <div class="result" id="result">ã¾ã è³¼å…¥ã—ã¦ã¾ã›ã‚“ã€‚</div>
      <div class="btns" style="margin-top:12px;">
        <button class="secondary" id="backToBet">å±•ç¤ºãƒ»è²·ã„ç›®ã«æˆ»ã‚‹</button>
      </div>
    </div>
  </section>

</div>

<script>
  /* ===== Screen switch ===== */
  const screenBet = document.getElementById("screenBet");
  const screenRace = document.getElementById("screenRace");
  const screenResult = document.getElementById("screenResult");
  function showScreen(which){
    screenBet.classList.remove("active");
    screenRace.classList.remove("active");
    screenResult.classList.remove("active");
    which.classList.add("active");
    window.scrollTo({top:0, behavior:"instant"});
  }

  /* ===== Storage ===== */
  const store = {
    get(key, fallback) { const v = localStorage.getItem(key); return v === null ? fallback : JSON.parse(v); },
    set(key, value) { localStorage.setItem(key, JSON.stringify(value)); }
  };

  let money  = store.get("money", 10000);
  let plays  = store.get("plays", 0);
  let hits   = store.get("hits", 0);
  let betSum = store.get("betSum", 0);
  let paySum = store.get("paySum", 0);

  const $ = (id) => document.getElementById(id);
  function round1(x){ return Math.round(x*10)/10; }
  function round2(x){ return Math.round(x*100)/100; }
  function rand(min, max){ return Math.random()*(max-min)+min; }
  function randi(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function clamp(x, lo, hi){ return Math.min(Math.max(x, lo), hi); }
  function ease(t){ return t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }

  function updateKPI(){
    $("money").textContent = money;
    const roi = betSum > 0 ? (paySum / betSum * 100) : 0;
    const hitRate = plays > 0 ? (hits / plays * 100) : 0;
    $("roi").textContent = roi.toFixed(1);
    $("hitRate").textContent = hitRate.toFixed(1);

    store.set("money", money);
    store.set("plays", plays);
    store.set("hits", hits);
    store.set("betSum", betSum);
    store.set("paySum", paySum);
  }

  /* ===== Rank ===== */
  const RANKS = ["A1","A2","B1","B2"];
  const RANK_WEIGHT = { A1: 1.00, A2: 0.78, B1: 0.55, B2: 0.33 };

  /* ===== Colors ===== */
  const BOAT_COLOR={1:"#ffffff",2:"#000000",3:"#e60012",4:"#0057ff",5:"#ffcc00",6:"#1ea64a"};
  const LANE_COL={1:"#ffffff",2:"#111111",3:"#e60012",4:"#0057ff",5:"#ffcc00",6:"#1ea64a"};

  /* ===== Venues ===== */
  const VENUES = [
    { key:"suminoe", name:"ä½é‡ç”°", trend:"ã‚¤ãƒ³å¼·ã‚", chaosBase: 1.5, windMul:0.9, waveMul:0.8,
      laneBias:[1.18,1.07,1.00,0.96,0.92,0.88], laneLabel:"1-2ãŒå¼·ã‚" },
    { key:"marugame", name:"ä¸¸ç¥", trend:"æ¨™æº–", chaosBase: 2.2, windMul:1.0, waveMul:1.0,
      laneBias:[1.10,1.04,1.00,0.98,0.96,0.94], laneLabel:"æ™®é€šï¼ˆã¡ã‚‡ã„ã‚¤ãƒ³ï¼‰" },
    { key:"kiryu", name:"éœ§ç”Ÿ", trend:"å¤–ä¼¸ã³", chaosBase: 2.4, windMul:1.1, waveMul:1.0,
      laneBias:[1.05,1.02,1.00,1.03,1.06,1.08], laneLabel:"å¤–ãŒä¼¸ã³ã‚„ã™ã„" },
    { key:"toda", name:"æˆ¸æ³¢", trend:"è’ã‚Œå¯„ã‚Š", chaosBase: 3.2, windMul:1.2, waveMul:1.1,
      laneBias:[1.02,1.00,1.00,1.00,1.00,1.01], laneLabel:"ã‚³ãƒ¼ã‚¹å·®å°ï¼ˆè’ã‚Œï¼‰" },
  ];
  function chaosLevelLabel(c){ if(c < 3) return "ä½"; if(c < 6) return "ä¸­"; if(c < 9) return "é«˜"; return "æ¿€é«˜"; }

  /* ===== Race State ===== */
  let race = null;
  let isRacing = false;
  let animReq = null;

  function generateMotorStats(){
    const r2 = round1(rand(15, 60));
    const r3 = round1(clamp(r2 + rand(5, 25), 20, 90));
    return { r2, r3 };
  }

  function generateStartExST(rank, motorR2){
    let st = rand(0.06, 0.26);
    st -= RANK_WEIGHT[rank] * 0.03;
    st -= (motorR2 / 100) * 0.01;
    if(Math.random() < 0.06) st -= rand(0.02, 0.05);
    if(Math.random() < 0.06) st += rand(0.02, 0.06);
    return clamp(st, 0.01, 0.30);
  }

  function generateRace(){
    const venueKey = $("venue").value || VENUES[0].key;
    const venue = VENUES.find(v=>v.key===venueKey) || VENUES[0];

    const wind = round1(rand(0, 10));
    const wave = round1(rand(0, 8));
    const water = venue.trend;

    const boats = [];
    for(let n=1;n<=6;n++){
      const motor = generateMotorStats();
      const rank = RANKS[randi(0, RANKS.length-1)];
      const stEx = generateStartExST(rank, motor.r2);

      boats.push({
        id:n,
        exTime: round2(rand(6.70, 6.95)),
        rank,
        local: randi(1,5),
        motorR2: motor.r2,
        motorR3: motor.r3,
        stEx,
        st: null,
        stLabel: "-",
        status: "OK",
        str: 0,
        exRank: 0,
        vibe: "â–³",
      });
    }

    race = { venue, wind, wave, water, boats };
  }

  function chaos(){
    return race.venue.chaosBase
      + (race.wind * 0.6 * race.venue.windMul)
      + (race.wave * 0.8 * race.venue.waveMul);
  }

  function motorScore(b){ return (b.motorR2 * 1.0) + (b.motorR3 * 0.35); }
  function rankScore(b){ return RANK_WEIGHT[b.rank] * 100; }
  function laneMul(b){ return race.venue.laneBias[b.id-1] ?? 1.0; }
  function stExScore(b){ return (0.20 - b.stEx) * 140; }

  function strength(b){
    const timeScore  = (6.98 - b.exTime) * 110;
    const mScore = motorScore(b);
    const rScore = rankScore(b);
    const localScore = b.local * 6;
    const stScore = stExScore(b);

    let waterMul = 1.0;
    if(race.water === "ã‚¤ãƒ³å¼·ã‚"){
      waterMul = (b.id <= 2) ? 1.06 : 0.98;
    } else if(race.water === "å¤–ä¼¸ã³"){
      waterMul = (b.id >= 4) ? 1.06 : 0.98;
    } else if(race.water === "è’ã‚Œå¯„ã‚Š"){
      waterMul = 0.97;
    }

    const c = chaos();
    const compress = Math.max(0.60, 1.0 - c / 22.0);
    const courseMul = laneMul(b);
    const raw = (timeScore * 1.05) + (mScore * 1.15) + (rScore * 0.90) + localScore + (stScore * 1.0);

    return raw * compress * waterMul * courseMul;
  }

  function vibeBadge(v){
    if(v==="â—" || v==="â—‹") return `<span class="badge b-good">${v}</span>`;
    if(v==="â–³") return `<span class="badge b-mid">${v}</span>`;
    return `<span class="badge b-bad">${v}</span>`;
  }

  function computeStrengths(){
    for(const b of race.boats) b.str = strength(b);

    const sorted = [...race.boats].sort((a,b)=>b.str-a.str);
    for(let i=0;i<sorted.length;i++){
      race.boats.find(x=>x.id===sorted[i].id).exRank = i+1;
    }

    const c = chaos();
    const jitter = clamp(c / 8.0, 0.1, 1.2);
    for(const b of race.boats){
      const n = rand(-1.0*jitter, 1.0*jitter);
      const base = b.exRank + n;
      if(base <= 1.6) b.vibe = "â—";
      else if(base <= 2.7) b.vibe = "â—‹";
      else if(base <= 4.2) b.vibe = "â–³";
      else b.vibe = "Ã—";
    }
  }

  function renderRace(){
    $("wind").textContent = race.wind.toFixed(1);
    $("wave").textContent = race.wave.toFixed(1);
    $("trend").textContent = race.water;
    $("chaosLabel").textContent = chaosLevelLabel(chaos());
    $("laneTrend").textContent = race.venue.laneLabel;

    const tbody = $("boats");
    tbody.innerHTML = "";
    for(const b of race.boats){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><b>${b.id}</b>å·è‰‡</td>
        <td><b>${b.exRank}</b>ä½</td>
        <td>${vibeBadge(b.vibe)}</td>
        <td><b>${b.rank}</b></td>
        <td class="mono">${b.exTime.toFixed(2)}</td>
        <td class="mono">${b.stEx.toFixed(2)}</td>
        <td class="mono">2é€£ ${b.motorR2.toFixed(1)}%<br>3é€£ ${b.motorR3.toFixed(1)}%</td>
        <td class="mono">${b.str.toFixed(1)}</td>
        <td class="mono"><b>${b.stLabel}</b></td>
      `;
      tbody.appendChild(tr);
    }

    const fb=$("formationBody");
    fb.innerHTML="";
    for(let n=1;n<=6;n++){
      const b=race.boats[n-1];
      const tr=document.createElement("tr");
      tr.innerHTML=`
        <td class="colLane">
          <div class="laneBar lane${n}"></div>
          <div class="laneNum">${n}</div>
        </td>
        <td class="playerBox">
          <b>${b.rank}</b><br>
          <span class="playerMeta">å±•ç¤º${b.exRank}${b.vibe} / å±•ç¤ºST${b.stEx.toFixed(2)} / 2é€£${b.motorR2.toFixed(1)}%</span>
        </td>
        <td>
          <div class="pickGrid">
            <div class="pickBtn" data-place="1" data-id="${n}">${n}</div>
            <div class="pickBtn" data-place="2" data-id="${n}">${n}</div>
            <div class="pickBtn" data-place="3" data-id="${n}">${n}</div>
          </div>
        </td>
      `;
      fb.appendChild(tr);
    }

    document.querySelectorAll(".pickBtn").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        if(isRacing) return;
        togglePick(parseInt(btn.dataset.place,10), parseInt(btn.dataset.id,10));
      });
    });

    syncFormationButtons();
    updateFormationSummary();
    updatePreviewOdds();
  }

  /* ===== Odds ===== */
  function oddsWin(sel){
    const s = race.boats[sel-1].str;
    const c = chaos();
    return round2(clamp(20.0 - (s / 175.0) + (c / 10.0), 1.2, 22.0));
  }
  function oddsExacta(a,b){
    const sa = race.boats[a-1].str;
    const sb = race.boats[b-1].str;
    const c = chaos();
    const base = 90.0 - ((sa + sb) / 175.0);
    const bump = 1.0 + c / 9.0;
    return round2(clamp(base * bump / 10.0, 2.0, 280.0));
  }
  function oddsTrifecta(a,b,c3){
    const sa = race.boats[a-1].str;
    const sb = race.boats[b-1].str;
    const sc = race.boats[c3-1].str;
    const c = chaos();
    const base = 310.0 - ((sa + sb + sc) / 125.0);
    const bump = 1.0 + c / 8.5;
    return round2(clamp(base * bump / 10.0, 6.0, 999.9));
  }

  /* ===== æœ¬ç•ªST ===== */
  function generateRaceST(b){
    const c = chaos();
    const spread = 0.015 + (c / 200);
    const stableMul = 1.0 - (RANK_WEIGHT[b.rank] * 0.25);
    const realSpread = spread * clamp(0.75 + stableMul, 0.75, 1.15);
    let st = b.stEx + rand(-realSpread, realSpread);
    st -= (b.motorR2 / 100) * 0.005;
    return clamp(st, 0.01, 0.35);
  }

  /* ===== simulate (ã‚´ãƒ¼ãƒ«é †) ===== */
  function simulateRace(){
    for(const b of race.boats){
      const st = generateRaceST(b);
      b.st = st; b.status="OK"; b.stLabel = st.toFixed(2);
      if(st < 0.03){ b.status="F"; b.stLabel="F"; }
      else if(st > 0.28){ b.status="L"; b.stLabel="L"; }
    }

    const strengths=race.boats.map(b=>b.str);
    const minS=Math.min(...strengths), maxS=Math.max(...strengths);
    const span=Math.max(1, maxS-minS);
    const RUNUP_MS=1300;
    const BASE_1LAP_MS=5600; // é…ã‚
    const c=chaos();

    const perBoat=race.boats.map(b=>{
      const base=(b.str-minS)/span;
      const speed=0.72+base*0.14;
      const startDelay=clamp((b.st-0.05)*1200,0,900);
      const skill=(RANK_WEIGHT[b.rank]*0.55)+(b.motorR2/100*0.25)+clamp((0.22-b.stEx)*1.6,-0.2,0.35);
      const turnLoss=(260+c*35)*(1.05-clamp(skill,0,0.95));
      const lapMs=(BASE_1LAP_MS/speed)+turnLoss*2 + rand(-80,80)*(0.5+c/10);

      const excluded=b.status!=="OK";
      const totalMs=excluded?Infinity:(RUNUP_MS+startDelay+lapMs*3);
      return {id:b.id,status:b.status,startDelay,lapMs,totalMs};
    });

    const order=perBoat.filter(x=>x.status==="OK").sort((a,b)=>a.totalMs-b.totalMs).map(x=>x.id);
    const excluded=perBoat.filter(x=>x.status!=="OK").map(x=>({id:x.id,status:x.status}));
    const map=new Map(perBoat.map(x=>[x.id,x]));
    return {order,excluded,perBoatMap:map,RUNUP_MS};
  }

  /* ===== Formation ===== */
  let f1=new Set(), f2=new Set(), f3=new Set();
  function betCols(){ const t=$("betType").value; return (t==="win")?1:(t==="exacta")?2:3; }
  function clearIrrelevantSets(){ const cols=betCols(); if(cols<3) f3.clear(); if(cols<2) f2.clear(); }
  function togglePick(place,boatId){
    const cols=betCols(); if(place>cols) return;
    const S=place===1?f1:place===2?f2:f3;
    S.has(boatId)?S.delete(boatId):S.add(boatId);
    syncFormationButtons(); updateFormationSummary(); updatePreviewOdds();
  }
  function setAll(place){
    const cols=betCols(); if(place>cols) return;
    const S=place===1?f1:place===2?f2:f3;
    S.clear(); for(let n=1;n<=6;n++) S.add(n);
    syncFormationButtons(); updateFormationSummary(); updatePreviewOdds();
  }
  function clearFormation(){
    f1.clear(); f2.clear(); f3.clear();
    syncFormationButtons(); updateFormationSummary(); updatePreviewOdds();
  }
  function buildCombos(){
    const t=$("betType").value;
    const A=[...f1], B=[...f2], C=[...f3];
    const combos=[];
    if(t==="win"){ for(const a of A) combos.push([a]); }
    else if(t==="exacta"){ for(const a of A) for(const b of B) if(a!==b) combos.push([a,b]); }
    else { for(const a of A) for(const b of B) for(const c of C) if(a!==b && a!==c && b!==c) combos.push([a,b,c]); }
    return combos;
  }
  function syncFormationButtons(){
    const cols=betCols();
    const head=$("headLabels");
    head.classList.toggle("cols1", cols===1);
    head.classList.toggle("cols2", cols===2);
    head.innerHTML="";
    const labels = cols===1 ? ["1ç€"] : cols===2 ? ["1ç€","2ç€"] : ["1ç€","2ç€","3ç€"];
    for(const s of labels){
      const d=document.createElement("div");
      d.style.textAlign="center"; d.textContent=s; head.appendChild(d);
    }

    document.querySelectorAll(".pickGrid").forEach(g=>{
      g.classList.toggle("cols1", cols===1);
      g.classList.toggle("cols2", cols===2);
    });

    document.querySelectorAll(".pickBtn").forEach(btn=>{
      const place=parseInt(btn.dataset.place,10);
      const id=parseInt(btn.dataset.id,10);
      btn.style.display = (place<=cols) ? "block" : "none";
      const on=(place===1?f1:place===2?f2:f3).has(id);
      btn.classList.toggle("on",on);
    });

    $("formationHint").textContent =
      cols===1 ? "å˜å‹ï¼šã€1ç€ã€åˆ—ã ã‘æŠ¼ã—ã¦è²·ã†" :
      cols===2 ? "2é€£å˜ï¼šã€1ç€ã€ã€2ç€ã€ã®2åˆ—ã‚’æŠ¼ã—ã¦è²·ã†ï¼ˆåŒä¸€è‰‡ã¯è‡ªå‹•é™¤å¤–ï¼‰" :
               "3é€£å˜ï¼š3åˆ—ãœã‚“ã¶æŠ¼ã—ã¦è²·ã†ï¼ˆåŒä¸€è‰‡ã¯è‡ªå‹•é™¤å¤–ï¼‰";

    $("all2").disabled = cols<2;
    $("all3").disabled = cols<3;
  }
  function updateFormationSummary(){
    clearIrrelevantSets();
    const combos=buildCombos();
    const stake=parseInt($("stake").value,10)||0;
    const total=stake*combos.length;
    $("combos").textContent=combos.length;
    $("totalStake").textContent=total;
    $("combos2").textContent=combos.length;
    $("totalStake2").textContent=total;
  }

  function updatePreviewOdds(){
    const combos=buildCombos();
    if(combos.length===0){ $("previewOdds").textContent="-ï¼ˆé¸æŠã—ã¦ã­ï¼‰"; return; }
    let minO=Infinity,maxO=-Infinity;
    const t=$("betType").value;
    for(const c of combos){
      const o = (t==="win") ? oddsWin(c[0]) :
                (t==="exacta") ? oddsExacta(c[0],c[1]) :
                                 oddsTrifecta(c[0],c[1],c[2]);
      minO=Math.min(minO,o); maxO=Math.max(maxO,o);
    }
    $("previewOdds").textContent = (minO===maxO) ? minO.toFixed(2) : `${minO.toFixed(2)}ã€œ${maxO.toFixed(2)}ï¼ˆå„ç›®ï¼‰`;
  }

  /* ===== Canvas setup ===== */
  const cv = document.getElementById("raceCanvas");
  const ctx = cv.getContext("2d");
  function resizeCanvas(){
    const rect = cv.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    cv.width = Math.floor(rect.width * dpr);
    cv.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // æç”»åº§æ¨™ã‚’CSSãƒ”ã‚¯ã‚»ãƒ«ã«åˆã‚ã›ã‚‹
  }
  window.addEventListener("resize", ()=>{ if(screenRace.classList.contains("active")) resizeCanvas(); });

  /* ===== buoys + boats ===== */
  function drawBuoy(ctx,x,y,size){
    ctx.save(); ctx.translate(x,y);
    ctx.globalAlpha=0.15; ctx.fillStyle="#000";
    ctx.beginPath(); ctx.ellipse(0,size*0.30,size*0.48,size*0.18,0,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;

    ctx.lineWidth=Math.max(2,size*0.06);
    ctx.strokeStyle="#111"; ctx.fillStyle="#fff";
    ctx.beginPath();
    ctx.moveTo(0,-size*0.60);
    ctx.bezierCurveTo(size*0.55,-size*0.55,size*0.60,-size*0.05,size*0.42,size*0.25);
    ctx.bezierCurveTo(size*0.35,size*0.55,size*0.15,size*0.68,0,size*0.70);
    ctx.bezierCurveTo(-size*0.15,size*0.68,-size*0.35,size*0.55,-size*0.42,size*0.25);
    ctx.bezierCurveTo(-size*0.60,-size*0.05,-size*0.55,-size*0.55,0,-size*0.60);
    ctx.closePath(); ctx.fill(); ctx.stroke();

    ctx.fillStyle="#ff4a3a";
    ctx.beginPath();
    ctx.moveTo(0,-size*0.56);
    ctx.bezierCurveTo(size*0.20,-size*0.50,size*0.24,-size*0.10,size*0.15,size*0.55);
    ctx.bezierCurveTo(size*0.05,size*0.62,-size*0.05,size*0.62,-size*0.15,size*0.55);
    ctx.bezierCurveTo(-size*0.24,-size*0.10,-size*0.20,-size*0.50,0,-size*0.56);
    ctx.closePath(); ctx.fill();

    ctx.fillStyle="#fff";
    ctx.beginPath(); ctx.arc(0,-size*0.70,size*0.12,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.restore();
  }

  function drawBoatIcon(ctx, x, y, s, laneId){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(s,s);

    const fill = BOAT_COLOR[laneId] || "#fff";
    const stroke = (laneId===2) ? "#fff" : "#0f172a";
    ctx.fillStyle = fill;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(22,0);
    ctx.quadraticCurveTo(10,-12,-18,-10);
    ctx.quadraticCurveTo(-28,-1,-24,10);
    ctx.quadraticCurveTo(2,14,22,5);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    ctx.fillStyle="#f8fafc";
    ctx.beginPath();
    ctx.arc(-8,-6,6,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle="rgba(0,0,0,0.18)";
    ctx.stroke();

    ctx.fillStyle=(laneId===2)?"#fff":"#111";
    ctx.font="bold 10px sans-serif";
    ctx.fillText(String(laneId), -11, -2);

    ctx.restore();
  }

  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+rr, y);
      this.arcTo(x+w, y, x+w, y+h, rr);
      this.arcTo(x+w, y+h, x, y+h, rr);
      this.arcTo(x, y+h, x, y, rr);
      this.arcTo(x, y, x+w, y, rr);
      this.closePath();
      return this;
    }
  }

  function drawStartCutIn(ctx, W, H, dtMs, showMs, stRows){
    const t = clamp(dtMs / showMs, 0, 1);
    let scale = 1, alpha = 1;

    if(t < 0.18){
      const k = ease(t/0.18);
      scale = 0.78 + k*0.32;
      alpha = 0.10 + k*0.90;
    } else if(t < 0.75){
      scale = 1.06;
      alpha = 1;
    } else {
      const k = ease((t-0.75)/0.25);
      scale = 1.06 - k*0.18;
      alpha = 1 - k*1.05;
    }
    alpha = clamp(alpha, 0, 1);

    const cardW = 270, cardH = 210;
    const x0 = W*0.10, y0 = H*0.14;

    ctx.save();
    ctx.globalAlpha = alpha;

    ctx.translate(x0 + cardW/2, y0 + cardH/2);
    ctx.scale(scale, scale);
    ctx.translate(-(x0 + cardW/2), -(y0 + cardH/2));

    ctx.save();
    ctx.globalAlpha *= 0.25;
    ctx.fillStyle="#000";
    ctx.beginPath();
    ctx.roundRect(x0+8, y0+10, cardW, cardH, 14);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle="rgba(255,255,255,0.96)";
    ctx.strokeStyle="rgba(15, 23, 42, 0.14)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.roundRect(x0, y0, cardW, cardH, 16);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle="rgba(59,130,246,0.12)";
    ctx.beginPath();
    ctx.roundRect(x0, y0, cardW, 40, 16);
    ctx.fill();

    ctx.fillStyle="#0f172a";
    ctx.font="bold 15px sans-serif";
    ctx.fillText("ã‚¹ã‚¿ãƒ¼ãƒˆå±•ç¤º", x0+16, y0+26);

    ctx.fillStyle="#334155";
    ctx.font="12px sans-serif";
    ctx.fillText("ã‚³ãƒ¼ã‚¹", x0+16, y0+62);
    ctx.fillText("ä¸¦ã³", x0+92, y0+62);
    ctx.fillText("ST",   x0+210, y0+62);

    const rowY0 = y0+72;
    const rowH = 22;
    for(let i=0;i<6;i++){
      const lane = i+1;
      const st = stRows[i]?.stLabel ?? "-";
      const status = stRows[i]?.status ?? "OK";

      ctx.fillStyle = LANE_COL[lane];
      ctx.beginPath();
      ctx.roundRect(x0+10, rowY0+i*rowH+2, 18, rowH-4, 6);
      ctx.fill();
      ctx.strokeStyle="rgba(0,0,0,0.10)";
      ctx.stroke();

      ctx.fillStyle = (lane===2) ? "#fff" : "#0f172a";
      ctx.font="bold 12px sans-serif";
      ctx.fillText(String(lane), x0+16, rowY0+i*rowH+16);

      drawBoatIcon(ctx, x0+120, rowY0+i*rowH+13, 0.62, lane);

      let stColor = "#0f172a";
      if(status==="F") stColor = "#ef4444";
      if(status==="L") stColor = "#f97316";
      ctx.fillStyle = stColor;
      ctx.font = "bold 13px monospace";
      const stText = (status==="OK") ? st : (status==="F" ? "F" : "L");
      ctx.fillText(stText, x0+214, rowY0+i*rowH+16);
    }

    ctx.strokeStyle="rgba(250, 204, 21, 0.95)";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(x0+198, y0+46);
    ctx.lineTo(x0+198, y0+cardH-12);
    ctx.stroke();

    ctx.fillStyle="rgba(15,23,42,0.65)";
    ctx.font="11px sans-serif";
    ctx.fillText("â€»F/Lã¯é™¤å¤–æ‰±ã„", x0+150, y0+cardH-10);

    ctx.restore();
  }

  function playRaceAnimation3Laps(sim, onFinish){
    if(animReq) cancelAnimationFrame(animReq);
    resizeCanvas();

    const W = cv.getBoundingClientRect().width;
    const H = cv.getBoundingClientRect().height;

    const cx=W*0.52, cy=H*0.72, rx=W*0.34, ry=H*0.27;
    const startTheta=Math.PI/2;
    const laneOffset=[18,12,7,2,-3,-8];

    function proj(p){
      const k=clamp((p.y-(cy-ry))/((cy+ry)-(cy-ry)),0,1);
      const skew=1+(k-0.5)*0.12;
      return {x:(p.x-cx)*skew+cx+(k-0.5)*28,y:p.y,k};
    }

    function bg(){
      const g=ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,"#eef7ff"); g.addColorStop(0.40,"#f9fdff"); g.addColorStop(0.41,"#dff3ff"); g.addColorStop(1,"#bfe9ff");
      ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

      ctx.fillStyle="#fff"; ctx.fillRect(0,0,W,H*0.18);
      ctx.fillStyle="#e9eefb"; ctx.fillRect(0,H*0.18,W,6);
      for(let i=0;i<980;i++){
        const x=(i*19)%W, y=10+((i*37)%Math.floor(H*0.16));
        ctx.fillStyle=(i%6===0)?"#3b82f6":(i%6===1)?"#ef4444":(i%6===2)?"#22c55e":(i%6===3)?"#f59e0b":(i%6===4)?"#111827":"#8b5cf6";
        ctx.globalAlpha=0.18; ctx.fillRect(x,y,2,2);
      }
      ctx.globalAlpha=1;

      ctx.globalAlpha=0.55;
      for(let i=0;i<170;i++){
        const x=(i*41)%W, y=(i*89)%H;
        ctx.fillStyle=(i%3===0)?"#e6f3ff":(i%3===1)?"#f1fbff":"#dff7ff";
        ctx.beginPath(); ctx.arc(x,y,(i%6===0)?2.2:1.4,0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha=1;
    }

    function course(){
      ctx.lineWidth=18; ctx.strokeStyle="rgba(255,255,255,0.65)";
      ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); ctx.stroke();
      ctx.lineWidth=10; ctx.strokeStyle="rgba(210,242,255,0.9)";
      ctx.beginPath(); ctx.ellipse(cx,cy,rx+16,ry+10,0,0,Math.PI*2); ctx.stroke();

      const mr=proj({x:cx+rx,y:cy});
      const ml=proj({x:cx-rx,y:cy});
      drawBuoy(ctx,mr.x,mr.y,26+mr.k*20);
      drawBuoy(ctx,ml.x,ml.y,26+ml.k*20);

      const sg=proj({x:cx,y:cy+ry});
      ctx.strokeStyle="#111"; ctx.lineWidth=5;
      ctx.beginPath(); ctx.moveTo(sg.x-42,sg.y); ctx.lineTo(sg.x+42,sg.y); ctx.stroke();
      ctx.fillStyle="#111"; ctx.font="13px sans-serif";
      ctx.fillText("START / GOAL", sg.x-58, sg.y+26);
    }

    function boatDraw(id,p,ang,scale,label,lapNo){
      const color=BOAT_COLOR[id]||"#111";
      const isBlack=id===2, isWhite=id===1, isYellow=id===5;

      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(ang); ctx.scale(scale,scale);

      ctx.fillStyle=color;
      ctx.beginPath();
      ctx.moveTo(26,0);
      ctx.quadraticCurveTo(8,-16,-20,-12);
      ctx.quadraticCurveTo(-34,-2,-28,12);
      ctx.quadraticCurveTo(2,18,26,6);
      ctx.closePath(); ctx.fill();

      ctx.strokeStyle=isBlack?"#fff":"#111";
      ctx.lineWidth=(isWhite||isBlack||isYellow)?2.4:1.6;
      ctx.stroke();

      ctx.fillStyle="#f7fbff";
      ctx.beginPath(); ctx.arc(-10,-8,7.4,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle="rgba(0,0,0,0.22)"; ctx.lineWidth=1.2; ctx.stroke();

      ctx.fillStyle="rgba(30, 64, 175, 0.18)";
      ctx.beginPath(); ctx.ellipse(-8,-8,5.5,3.2,0.15,0,Math.PI*2); ctx.fill();

      ctx.fillStyle=isBlack?"#fff":"#111";
      ctx.font="bold 11px sans-serif";
      ctx.fillText(String(id),-13,-4);

      ctx.globalAlpha=0.75;
      ctx.fillStyle="rgba(255,255,255,0.92)";
      for(let i=0;i<14;i++){
        const x=-34-i*3-rand(0,10);
        const y=7+rand(-12,12);
        ctx.beginPath(); ctx.arc(x,y,rand(1.1,3.0),0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha=1;

      ctx.restore();

      ctx.fillStyle="#333"; ctx.font="12px sans-serif";
      ctx.fillText(`${id}(${label})`, p.x+20, p.y+4);
      ctx.fillStyle="#666"; ctx.font="12px sans-serif";
      ctx.fillText(`${lapNo}/3`, p.x-10, p.y-20);
    }

    const okIds=sim.order.slice();
    const map=sim.perBoatMap;
    const RUNUP_MS=sim.RUNUP_MS;

    const CUTIN_START = RUNUP_MS - 260;
    const CUTIN_SHOW  = 1650;

    const sg=proj({x:cx,y:cy+ry});
    const runStart={x:sg.x-320,y:sg.y+10};

    const maxTotal=Math.max(...okIds.map(id=>map.get(id).totalMs));
    const endAt=maxTotal+400;

    const stRows = [];
    for(let i=1;i<=6;i++){
      const b = race.boats[i-1];
      stRows.push({id:i, stLabel:b.stLabel, status:b.status});
    }

    const t0=performance.now();

    function frame(now){
      const dt=now-t0;
      bg(); course();

      const items=[];
      for(const id of okIds){
        const b=race.boats[id-1];
        const pb=map.get(id);
        const startAt=RUNUP_MS+pb.startDelay;

        if(dt<RUNUP_MS){
          const k=ease(clamp(dt/RUNUP_MS,0,1));
          const x=runStart.x+k*320;
          const y=runStart.y+(laneOffset[id-1]||0)*0.18;
          const p=proj({x,y});
          const scale=0.78+p.k*0.72;
          items.push({id,p,ang:0,scale,y:p.y,lapNo:1,label:b.stLabel});
          continue;
        }

        const runningT=dt-startAt;
        const totalLapMs=pb.lapMs*3;
        const clampedT=clamp(runningT,0,totalLapMs);

        const lapFloat=clampedT/pb.lapMs;
        const lapNo=clamp(Math.floor(lapFloat)+1,1,3);
        const within=lapFloat-Math.floor(lapFloat);

        const theta = startTheta - (Math.PI*2)*within;
        const lane=(laneOffset[id-1]||0);
        const px=cx+(rx+lane*0.55)*Math.cos(theta);
        const py=cy+(ry+lane*0.35)*Math.sin(theta);
        const p=proj({x:px,y:py});

        const eps=0.002;
        const th2 = theta - (Math.PI*2)*eps;
        const qx=cx+(rx+lane*0.55)*Math.cos(th2);
        const qy=cy+(ry+lane*0.35)*Math.sin(th2);
        const q=proj({x:qx,y:qy});
        const ang=Math.atan2(q.y-p.y,q.x-p.x);

        const scale=0.78+p.k*0.72;
        items.push({id,p,ang,scale,y:p.y,lapNo,label:b.stLabel});
      }

      items.sort((a,b)=>a.y-b.y);
      for(const it of items) boatDraw(it.id,it.p,it.ang,it.scale,it.label,it.lapNo);

      if(dt >= CUTIN_START && dt <= CUTIN_START + CUTIN_SHOW){
        drawStartCutIn(ctx, W, H, dt - CUTIN_START, CUTIN_SHOW, stRows);
      }

      if(dt>=endAt){
        if(typeof onFinish==="function") onFinish();
        return;
      }
      animReq=requestAnimationFrame(frame);
    }

    animReq=requestAnimationFrame(frame);
  }

  /* ===== settle (çµæœç”»é¢ã¸) ===== */
  function settleAfterFinish(sim, combos, stakePerCombo){
    const finishing=sim.order;
    const excluded=sim.excluded;
    const t=$("betType").value;

    let hitCombo=null;
    if(t==="win"){
      if(finishing.length>=1){
        const win=finishing[0];
        hitCombo = combos.find(c=>c[0]===win) || null;
      }
    }else if(t==="exacta"){
      if(finishing.length>=2){
        const a=finishing[0], b=finishing[1];
        hitCombo = combos.find(c=>c[0]===a && c[1]===b) || null;
      }
    }else{
      if(finishing.length>=3){
        const a=finishing[0], b=finishing[1], c=finishing[2];
        hitCombo = combos.find(x=>x[0]===a && x[1]===b && x[2]===c) || null;
      }
    }

    let payout=0;
    if(hitCombo){
      hits+=1;
      const o = (t==="win") ? oddsWin(hitCombo[0]) :
                (t==="exacta") ? oddsExacta(hitCombo[0],hitCombo[1]) :
                                 oddsTrifecta(hitCombo[0],hitCombo[1],hitCombo[2]);
      payout=Math.floor(stakePerCombo*o);
      paySum+=payout;
      money+=payout;
    }

    updateKPI();

    const exText=excluded.length?`ï¼ˆé™¤å¤–: ${excluded.map(x=>`${x.id}${x.status}`).join(" / ")}ï¼‰`:"";
    const betLabel = (t==="win") ? "å˜å‹" : (t==="exacta") ? "2é€£å˜" : "3é€£å˜";

    $("result").innerHTML=`
      <div>å ´ï¼š<b>${race.venue.name}</b> / æ°´é¢ï¼š<b>${race.water}</b> / è’ã‚Œï¼š<b>${chaosLevelLabel(chaos())}</b>ï¼ˆé¢¨${race.wind.toFixed(1)}m æ³¢${race.wave.toFixed(1)}cmï¼‰</div>
      <div>${betLabel} ãƒ•ã‚©ãƒ¼ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼š<b>${combos.length}</b>ç‚¹ / 1ç‚¹<b>${stakePerCombo}</b>å†† / ç·æŠ•è³‡<b>${stakePerCombo*combos.length}</b>å††</div>
      <div>ç€é †ï¼ˆã‚´ãƒ¼ãƒ«é †ï¼‰: <b>${finishing.join("-") || "ï¼ˆå®Œèµ°ãªã—ï¼‰"}</b> ${exText}</div>
      <div>${hitCombo
        ? `<span class="hit">ğŸ¯ çš„ä¸­ï¼</span> çš„ä¸­ç›®ï¼š<b>${hitCombo.join("-")}</b> / æ‰•æˆ»ï¼š<b>${payout}</b>å††`
        : `<span class="miss">ğŸ’¤ ãƒã‚ºãƒ¬</span> æ‰•æˆ»ï¼š<b>0</b>å††`
      }</div>
    `;

    // â˜…çµæœç”»é¢ã¸
    showScreen(screenResult);
  }

  /* ===== buy & start ===== */
  function buyAndStart(){
    if(isRacing) return;

    const stake=parseInt($("stake").value,10);
    if(!Number.isFinite(stake)||stake<100){
      alert("æ›ã‘é‡‘ã¯100å††ä»¥ä¸Šã«ã—ã¦ã­");
      return;
    }

    const combos=buildCombos();
    if(combos.length===0){
      alert("è²·ã„ç›®ã‚’é¸ã‚“ã§ã­ï¼ˆæ•°å­—æŠ¼ã—ã¦ï¼ï¼‰");
      return;
    }

    const total=stake*combos.length;
    if(total>money){
      alert(`æ‰€æŒé‡‘ãŒè¶³ã‚Šã¸ã‚“â€¦ï¼ˆç·æŠ•è³‡ ${total}å††ï¼‰`);
      return;
    }

    // è³¼å…¥ç¢ºå®š
    plays+=1; betSum+=total; money-=total; updateKPI();

    // æœ¬ç•ªSTç¢ºå®šï¼†é™¤å¤–åˆ¤å®š
    const sim=simulateRace();

    // ãƒ†ãƒ¼ãƒ–ãƒ«ã¯æœ¬ç•ªSTãŒè¦‹ãˆã‚‹çŠ¶æ…‹ã«ã—ã¦ãŠãï¼ˆå±•ç¤ºç”»é¢å´ã®è¡¨ç¤ºç”¨ï¼‰
    renderRace();

    // â˜…ãƒ¬ãƒ¼ã‚¹ç”»é¢ã¸åˆ‡æ›¿
    showScreen(screenRace);

    isRacing=true;
    $("buyRun").disabled=true;
    $("newRace").disabled=true;
    $("betType").disabled=true;

    // ã‚¢ãƒ‹ãƒ¡å†ç”Ÿ â†’ çµ‚äº†å¾Œã«çµæœã¸
    playRaceAnimation3Laps(sim, ()=>{
      isRacing=false;
      $("buyRun").disabled=false;
      $("newRace").disabled=false;
      $("betType").disabled=false;

      settleAfterFinish(sim, combos, stake);
    });
  }

  /* ===== Events ===== */
  $("stake").addEventListener("input", () => {
    $("stake").value = $("stake").value.replace(/[^\d]/g, "");
    updateFormationSummary();
    updatePreviewOdds();
  });

  $("betType").addEventListener("change", () => {
    if(isRacing) return;
    clearIrrelevantSets();
    syncFormationButtons();
    updateFormationSummary();
    updatePreviewOdds();
  });

  $("buyRun").addEventListener("click", buyAndStart);

  $("newRace").addEventListener("click", () => {
    if(isRacing) return;
    generateRace();
    computeStrengths();
    for(const b of race.boats){ b.stLabel = "-"; b.st=null; b.status="OK"; }
    clearFormation();
    renderRace();
  });

  $("venue").addEventListener("change", () => {
    if(isRacing) return;
    generateRace();
    computeStrengths();
    for(const b of race.boats){ b.stLabel = "-"; b.st=null; b.status="OK"; }
    clearFormation();
    renderRace();
  });

  $("all1").addEventListener("click", ()=>{ if(!isRacing) setAll(1); });
  $("all2").addEventListener("click", ()=>{ if(!isRacing) setAll(2); });
  $("all3").addEventListener("click", ()=>{ if(!isRacing) setAll(3); });
  $("clearAll").addEventListener("click", ()=>{ if(!isRacing) clearFormation(); });

  $("backToBet").addEventListener("click", ()=>{
    if(isRacing) return;
    showScreen(screenBet);
  });

  function initVenue(){
    const vSel = $("venue");
    vSel.innerHTML = "";
    for(const v of VENUES){
      const opt = document.createElement("option");
      opt.value = v.key;
      opt.textContent = v.name;
      vSel.appendChild(opt);
    }
    vSel.value = "suminoe";
  }

  /* ===== Init ===== */
  updateKPI();
  initVenue();
  generateRace();
  computeStrengths();
  renderRace();

  // åˆæœŸé¸æŠï¼ˆãŠè©¦ã—ï¼‰
  f1.add(1); f2.add(2); f3.add(3);
  syncFormationButtons();
  updateFormationSummary();
  updatePreviewOdds();
</script>
</body>
</html>
